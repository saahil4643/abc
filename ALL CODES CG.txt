PRACTICAL 2 


#include <iostream>
#include <GL/glut.h>
#include <cmath>
using namespace std;

int Algo, type;

void Init()
{
    glClearColor(0, 0, 0, 0);
    glColor3f(0, 1, 0);
    glPointSize(2.0);  // Make points visible
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 640, 0, 480);
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
}

int sign(float a)
{
    if (a == 0) return 0;
    return (a > 0) ? 1 : -1;
}

void plotPoint(int x, int y, int i, int& cnt)
{
    bool shouldDraw = false;

    if (type == 1) shouldDraw = true;
    else if (type == 2) shouldDraw = (i % 2 == 0);
    else if (type == 3)
    {
        if (cnt <= 10) shouldDraw = true;
        cnt++;
        if (cnt == 15) cnt = 1;
    }

    if (shouldDraw)
    {
        glBegin(GL_POINTS);
        glVertex2i(x, y);
        glEnd();
    }
}

void B_Line(int x1, int y1, int x2, int y2, int t)
{
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int s1 = sign(x2 - x1);
    int s2 = sign(y2 - y1);
    int interchange = 0;

    if (dy > dx)
    {
        swap(dx, dy);
        interchange = 1;
    }

    int p = 2 * dy - dx;
    int x = x1, y = y1, cnt = 1;

    for (int i = 0; i <= dx; i++)
    {
        plotPoint(x, y, i, cnt);

        if (p >= 0)
        {
            if (interchange)
                x += s1;
            else
                y += s2;
            p = p + 2 * (dy - dx);
        }
        else
        {
            p = p + 2 * dy;
        }

        if (interchange)
            y += s2;
        else
            x += s1;
    }
    glFlush();
}

void DDA_LINE(int x1, int y1, int x2, int y2, int t)
{
    float dx = x2 - x1;
    float dy = y2 - y1;
    float steps = max(abs(dx), abs(dy));

    float xin = dx / steps;
    float yin = dy / steps;

    float x = x1 + 0.5 * sign(xin);
    float y = y1 + 0.5 * sign(yin);

    int cnt = 1;
    for (int i = 0; i <= steps; i++)
    {
        plotPoint(round(x), round(y), i, cnt);
        x += xin;
        y += yin;
    }
    glFlush();
}

void display()
{
    DDA_LINE(0, 240, 640, 240, 1);    // Horizontal axis
    B_Line(320, 0, 320, 480, 1);      // Vertical axis
}

void mymouse(int b, int s, int x, int y)
{
    static int x_s, y_s, x_e, y_e, pt = 0;
    if (b == GLUT_LEFT_BUTTON && s == GLUT_DOWN)
    {
        if (pt == 0)
        {
            x_s = x;
            y_s = 480 - y;
            pt++;
            glBegin(GL_POINTS);
            glVertex2i(x_s, y_s);
            glEnd();
        }
        else
        {
            x_e = x;
            y_e = 480 - y;
            glBegin(GL_POINTS);
            glVertex2i(x_e, y_e);
            glEnd();

            if (Algo == 1)
                DDA_LINE(x_s, y_s, x_e, y_e, type);
            else if (Algo == 2)
                B_Line(x_s, y_s, x_e, y_e, type);

            pt = 0;
        }
    }
    else if (b == GLUT_RIGHT_BUTTON && s == GLUT_DOWN)
    {
        pt = 0;
    }
    glFlush();
}

int main(int argc, char** argv)
{
    cout << "\nSelect the Algorithm \n 1. DDA \n 2. Bresenham's \n";
    cin >> Algo;
    cout << "Select the Line Type \n 1. Simple Line \n 2. Dotted Line \n 3. Dashed Line \n";
    cin >> type;

    if ((Algo != 1 && Algo != 2) || (type < 1 || type > 3))
    {
        cout << "\nInvalid input options.\n";
        return 0;
    }

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowPosition(100, 100);
    glutInitWindowSize(640, 480);
    glutCreateWindow("Line Drawing Algorithm");
    Init();
    glutDisplayFunc(display);
    glutMouseFunc(mymouse);
    glutMainLoop();

    return 0;
}


practical 3 

#include <GL/glut.h>
#include <iostream>
using namespace std;

int r;

void plotCirclePoints(int x, int y)
{
    glBegin(GL_POINTS);
    
    glColor3f(1, 1, 0);  // Yellow
    glVertex2i(x + 320, y + 240);   // Octant 1
    glVertex2i(y + 320, x + 240);   // Octant 2

    glColor3f(1, 0, 1);  // Magenta
    glVertex2i(y + 320, -x + 240);  // Octant 3
    glVertex2i(x + 320, -y + 240);  // Octant 4

    glColor3f(0, 1, 1);  // Cyan
    glVertex2i(-x + 320, -y + 240); // Octant 5
    glVertex2i(-y + 320, -x + 240); // Octant 6

    glColor3f(1, 1, 0);  // Yellow again
    glVertex2i(-y + 320, x + 240);  // Octant 7
    glVertex2i(-x + 320, y + 240);  // Octant 8

    glEnd();
}

void B_circle()
{
    int x = 0, y = r;
    int d = 3 - 2 * r;

    while (x <= y)
    {
        plotCirclePoints(x, y);
        if (d < 0)
            d = d + 4 * x + 6;
        else
        {
            d = d + 4 * (x - y) + 10;
            y--;
        }
        x++;
    }
    glFlush();
}

void init()
{
    glClearColor(1, 1, 1, 0);     // White background
    glClear(GL_COLOR_BUFFER_BIT); // Clear the screen
    glColor3f(1, 0, 0);           // Default red (will change dynamically)
    glPointSize(2);               // Increase visibility of points
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 640, 0, 480);   // Set coordinate system
}

int main(int argc, char **argv)
{
    cout << "Enter Radius: ";
    cin >> r;

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowPosition(100, 100);
    glutInitWindowSize(640, 480);
    glutCreateWindow("Bresenham Circle Drawing");
    init();
    glutDisplayFunc(B_circle);
    glutMainLoop();
    return 0;
}


practical 4

#include <iostream>
#include <GL/glut.h>
using namespace std;

float R = 0, G = 0, B = 0;
int Algo;

void init() {
    glClearColor(1.0, 1.0, 1.0, 0.0);  // White background
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, 640, 0, 480);        // 2D orthographic projection
}

bool isSameColor(float a[3], float b[3]) {
    const float EPS = 0.01;
    return (abs(a[0] - b[0]) < EPS && abs(a[1] - b[1]) < EPS && abs(a[2] - b[2]) < EPS);
}

void floodFill(int x, int y, float *newCol, float *oldcol) {
    float pixel[3];
    glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, pixel);

    if (isSameColor(pixel, oldcol)) {
        glColor3f(newCol[0], newCol[1], newCol[2]);
        glBegin(GL_POINTS);
        glVertex2i(x, y);
        glEnd();
        glFlush();

        floodFill(x + 1, y, newCol, oldcol);
        floodFill(x - 1, y, newCol, oldcol);
        floodFill(x, y + 1, newCol, oldcol);
        floodFill(x, y - 1, newCol, oldcol);
    }
}

void boundaryFill(int x, int y, float *fillColor, float *boundaryColor) {
    float color[3];
    glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, color);

    if (!isSameColor(color, boundaryColor) && !isSameColor(color, fillColor)) {
        glColor3f(fillColor[0], fillColor[1], fillColor[2]);
        glBegin(GL_POINTS);
        glVertex2i(x, y);
        glEnd();
        glFlush();

        boundaryFill(x + 1, y, fillColor, boundaryColor);
        boundaryFill(x - 1, y, fillColor, boundaryColor);
        boundaryFill(x, y + 1, fillColor, boundaryColor);
        boundaryFill(x, y - 1, fillColor, boundaryColor);
    }
}

void mouse(int btn, int state, int x, int y) {
    y = 480 - y;  // Adjust for OpenGL coordinate system

    if (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        float boundaryColor[] = {1, 0, 0};    // Red border
        float oldColor[] = {1, 1, 1};         // White background
        float newColor[] = {R, G, B};

        if (Algo == 1)
            boundaryFill(x, y, newColor, boundaryColor);
        else if (Algo == 2)
            floodFill(x, y, newColor, oldColor);
    }
}

void B_Draw() {
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1, 0, 0);  // Red border
    glBegin(GL_LINE_LOOP);
    glVertex2i(150, 100);
    glVertex2i(300, 300);
    glVertex2i(450, 100);
    glEnd();
    glFlush();
}

void F_Draw() {
    glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_LINES);
    glColor3f(1, 0, 0);  // Red
    glVertex2i(150, 100);
    glVertex2i(300, 300);
    glEnd();

    glBegin(GL_LINES);
    glColor3f(0, 0, 1);  // Blue
    glVertex2i(300, 300);
    glVertex2i(450, 100);
    glEnd();

    glBegin(GL_LINES);
    glColor3f(0, 0, 0);  // Black
    glVertex2i(450, 100);
    glVertex2i(150, 100);
    glEnd();

    glFlush();
}

void goMenu(int value) {
    switch (value) {
        case 1:
            R = 0; G = 1; B = 0;  // Green
            break;
        case 2:
            R = 1; G = 1; B = 0;  // Yellow
            break;
        case 3:
            R = 1; G = 0; B = 1;  // Pink
            break;
    }
    glutPostRedisplay();
}

int main(int argc, char** argv) {
    cout << "\n\tSelect the Algorithm:";
    cout << "\n\t1. Boundary Fill Algorithm";
    cout << "\n\t2. Flood Fill Algorithm\n\t";
    cin >> Algo;

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(640, 480);
    glutInitWindowPosition(200, 200);
    glutCreateWindow("Boundary & Flood Fill Algorithm");

    init();

    // Create menu
    glutCreateMenu(goMenu);
    glutAddMenuEntry("Color 1 - Green", 1);
    glutAddMenuEntry("Color 2 - Yellow", 2);
    glutAddMenuEntry("Color 3 - Pink", 3);
    glutAttachMenu(GLUT_RIGHT_BUTTON);

    // Drawing shape based on algorithm
    if (Algo == 1)
        glutDisplayFunc(B_Draw);
    else
        glutDisplayFunc(F_Draw);

    glutMouseFunc(mouse);
    glutMainLoop();

    return 0;
}


Practical 5

#include <GL/glut.h>
#include <iostream>
using namespace std;

int wxmin = 200, wxmax = 500, wymax = 350, wymin = 100;
int points[20][2];
int edge = 0;
bool polygonClosed = false;

void init() {
    glClearColor(1.0,1.0,1.0,0.0);
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0,640,0,480);
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
}

void drawWindow() {
    glColor3f(0, 1, 0);
    glBegin(GL_LINE_LOOP);
    glVertex2i(wxmin, wymin);
    glVertex2i(wxmax, wymin);
    glVertex2i(wxmax, wymax);
    glVertex2i(wxmin, wymax);
    glEnd();
}

void DrawPolygon() {
    glClear(GL_COLOR_BUFFER_BIT);
    drawWindow();

    glColor3f(0.2, 0.2, 1);
    if (polygonClosed) {
        glBegin(GL_POLYGON);
        for(int i = 0; i < edge; i++)
            glVertex2i(points[i][0], points[i][1]);
        glEnd();
    } else {
        glBegin(GL_LINE_STRIP);
        for(int i = 0; i < edge; i++)
            glVertex2i(points[i][0], points[i][1]);
        glEnd();
    }
    glFlush();
}

// ---- Clipping Functions (copy from your code above) ----
// BottomClipping, TopClipping, LeftClipping, RightClipping 
// should be included here (unchanged from your full code)
// ---------------------------------------------------------

// Sample stub to close polygon on right click
void mouseClick(int button, int state, int x, int y) {
    y = 480 - y; // Flip y for OpenGL

    if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN && edge < 20 && !polygonClosed) {
        points[edge][0] = x;
        points[edge][1] = y;
        edge++;
        DrawPolygon();
    }

    if(button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN && edge >= 3) {
        points[edge][0] = points[0][0];
        points[edge][1] = points[0][1];
        edge++;
        polygonClosed = true;
        DrawPolygon();
    }
}

int BottomCliping(int e); // Add actual code
int TopCliping(int e);    // Add actual code
int leftCliping(int e);   // Add actual code
int RightCliping(int e);  // Add actual code

void keyboard(unsigned char key, int x, int y) {
    if(!polygonClosed) return;

    switch(key) {
        case '1':
            edge = leftCliping(edge); break;
        case '2':
            edge = RightCliping(edge); break;
        case '3':
            edge = TopCliping(edge); break;
        case '4':
            edge = BottomCliping(edge); break;
        case 'r': // Reset
            edge = 0;
            polygonClosed = false;
            break;
        default:
            return;
    }
    DrawPolygon();
}

void menu(int value) {
    keyboard((char)value, 0, 0);
}

int main(int argc, char **argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(640, 480);
    glutCreateWindow("Cohen Sutherland Polygon Clipping");
    init();
    glutDisplayFunc(DrawPolygon);
    glutMouseFunc(mouseClick);
    glutKeyboardFunc(keyboard);

    glutCreateMenu(menu);
    glutAddMenuEntry("Left Clip", '1');
    glutAddMenuEntry("Right Clip", '2');
    glutAddMenuEntry("Top Clip", '3');
    glutAddMenuEntry("Bottom Clip", '4');
    glutAddMenuEntry("Reset", 'r');
    glutAttachMenu(GLUT_RIGHT_BUTTON);

    glutMainLoop();
    return 0;
}


Practical 6 

#include <iostream>
#include <cmath>
#include <vector>
#include <GL/glut.h>
using namespace std;

int edge;
vector<int> xpoint, ypoint;
int ch;

double roundDouble(double d) {
    return floor(d + 0.5);
}

void init() {
    glClearColor(1.0,1.0,1.0,0.0);
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0,640,0,480);
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
}

void drawAxes() {
    glColor3f(0.7, 0.7, 0.7);
    glBegin(GL_LINES);
        glVertex2i(0, 240); glVertex2i(640, 240); // X-axis
        glVertex2i(320, 0); glVertex2i(320, 480); // Y-axis
    glEnd();
    glFlush();
}

void drawPolygon(const vector<int>& x, const vector<int>& y, float r, float g, float b) {
    glColor3f(r, g, b);
    glBegin(GL_POLYGON);
    for (int i = 0; i < edge; i++)
        glVertex2i(x[i], y[i]);
    glEnd();
    glFlush();
}

void translation() {
    int tx, ty;
    cout << "\nEnter Tx and Ty: ";
    cin >> tx >> ty;

    for (int i = 0; i < edge; i++) {
        xpoint[i] += tx;
        ypoint[i] += ty;
    }

    glClear(GL_COLOR_BUFFER_BIT);
    drawPolygon(xpoint, ypoint, 0, 0, 1); // Blue
}

void rotation() {
    int cx, cy;
    double theta;
    cout << "\nEnter arbitrary point (x, y): ";
    cin >> cx >> cy;
    cx += 320; cy += 240;

    cout << "Enter angle in degrees: ";
    cin >> theta;
    theta = theta * M_PI / 180.0;

    vector<int> newX(edge), newY(edge);
    for (int i = 0; i < edge; i++) {
        newX[i] = roundDouble((xpoint[i] - cx) * cos(theta) - (ypoint[i] - cy) * sin(theta) + cx);
        newY[i] = roundDouble((xpoint[i] - cx) * sin(theta) + (ypoint[i] - cy) * cos(theta) + cy);
    }

    glClear(GL_COLOR_BUFFER_BIT);
    drawAxes();
    drawPolygon(xpoint, ypoint, 1.0, 0.0, 0.0); // Red: Original
    drawPolygon(newX, newY, 0.0, 0.0, 1.0);     // Blue: Rotated
}

void scale() {
    int sx, sy;
    cout << "\nEnter scaling factors sx and sy: ";
    cin >> sx >> sy;

    vector<int> newX(edge), newY(edge);
    for (int i = 0; i < edge; i++) {
        int tx = xpoint[i] - 320;
        int ty = ypoint[i] - 240;
        newX[i] = tx * sx + 320;
        newY[i] = ty * sy + 240;
    }

    glClear(GL_COLOR_BUFFER_BIT);
    drawAxes();
    drawPolygon(xpoint, ypoint, 1.0, 0.0, 0.0); // Red: Original
    drawPolygon(newX, newY, 0.0, 0.0, 1.0);     // Blue: Scaled
}

void reflection() {
    char axis;
    cout << "\nEnter axis of reflection (X or Y): ";
    cin >> axis;

    vector<int> newX(edge), newY(edge);
    for (int i = 0; i < edge; i++) {
        if (axis == 'x' || axis == 'X') {
            newX[i] = xpoint[i];
            newY[i] = 480 - ypoint[i];
        } else if (axis == 'y' || axis == 'Y') {
            newX[i] = 640 - xpoint[i];
            newY[i] = ypoint[i];
        } else {
            cout << "Invalid axis!";
            return;
        }
    }

    glClear(GL_COLOR_BUFFER_BIT);
    drawAxes();
    drawPolygon(xpoint, ypoint, 1.0, 0.0, 0.0); // Red: Original
    drawPolygon(newX, newY, 0.0, 0.0, 1.0);     // Blue: Reflected
}

void Draw() {
    switch (ch) {
        case 1: scale(); break;
        case 2: rotation(); break;
        case 3: reflection(); break;
        case 4: translation(); break;
        default: cout << "Invalid choice\n"; break;
    }
}

int main(int argc, char** argv) {
    cout << "\n\t2D TRANSFORMATION MENU";
    cout << "\n1) Scaling";
    cout << "\n2) Rotation about arbitrary point";
    cout << "\n3) Reflection";
    cout << "\n4) Translation";
    cout << "\nEnter your choice: ";
    cin >> ch;

    if (ch >= 1 && ch <= 4) {
        cout << "\nEnter number of edges: ";
        cin >> edge;

        cout << "Enter coordinates (x y) for " << edge << " vertices:\n";
        for (int i = 0; i < edge; i++) {
            int x, y;
            cout << "Point " << i + 1 << ": ";
            cin >> x >> y;
            xpoint.push_back(x + 320); // Center shift
            ypoint.push_back(y + 240);
        }

        glutInit(&argc, argv);
        glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
        glutInitWindowSize(640, 480);
        glutInitWindowPosition(200, 200);
        glutCreateWindow("2D Transformations");
        init();
        glutDisplayFunc(Draw);
        glutMainLoop();
        return 0;
    } else {
        cout << "\nInvalid Input. Exiting.\n";
        return 0;
    }
}


practical 7 1 

#include <iostream>
#include <math.h>
#include <GL/glut.h>
using namespace std;

int x[4], y[4];

void init() {
    glClearColor(1.0, 1.0, 1.0, 0.0);  // White background
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0, 640, 0, 480);       // Coordinate system
    glClear(GL_COLOR_BUFFER_BIT);
}

void putPixel(double xt, double yt) {
    glColor3f(1, 0, 0);  // Red color
    glBegin(GL_POINTS);
    glVertex2d(xt, yt);
    glEnd();
    glFlush();
}

void drawBezierCurve() {
    glColor3f(0, 1, 0);  // Green lines between control points
    glBegin(GL_LINE_STRIP);
    for (int i = 0; i < 4; i++) {
        glVertex2i(x[i], y[i]);
    }
    glEnd();
    glFlush();

    double t;
    for (t = 0.0; t <= 1.0; t += 0.0005) {
        double xt = pow(1 - t, 3) * x[0] +
                    3 * t * pow(1 - t, 2) * x[1] +
                    3 * pow(t, 2) * (1 - t) * x[2] +
                    pow(t, 3) * x[3];

        double yt = pow(1 - t, 3) * y[0] +
                    3 * t * pow(1 - t, 2) * y[1] +
                    3 * pow(t, 2) * (1 - t) * y[2] +
                    pow(t, 3) * y[3];

        putPixel(xt, yt);
    }
}

int main(int argc, char** argv) {
    cout << "\n\t Enter the four control points (x y):\n";
    for (int i = 0; i < 4; i++) {
        cout << "Point " << i + 1 << ": ";
        cin >> x[i] >> y[i];
    }

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(640, 480);
    glutInitWindowPosition(200, 200);
    glutCreateWindow("Bezier Curve - 4 Control Points");
    init();
    glutDisplayFunc(drawBezierCurve);
    glutMainLoop();

    return 0;
}


practical 7 2 

#include <GL/glut.h>
#include <math.h>

// Initial starting point for drawing
GLfloat oldx = -0.7, oldy = 0.5;

// Recursive function to draw Koch curve
void drawKoch(GLfloat dir, GLfloat len, GLint iter) {
    GLdouble dirRad = 0.0174533 * dir;  // Convert degrees to radians
    GLfloat newX = oldx + len * cos(dirRad);
    GLfloat newY = oldy + len * sin(dirRad);

    if (iter == 0) {
        glVertex2f(oldx, oldy);
        glVertex2f(newX, newY);
        oldx = newX;
        oldy = newY;
    } else {
        iter--;
        drawKoch(dir, len, iter);     // 1st segment
        dir += 60.0;
        drawKoch(dir, len, iter);     // Peak
        dir -= 120.0;
        drawKoch(dir, len, iter);     // Descending
        dir += 60.0;
        drawKoch(dir, len, iter);     // Final segment
    }
}

// Display callback for OpenGL
void display() {
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(0.0, 1.0, 0.0);  // Green color for lines
    glBegin(GL_LINES);

    // Draw three sides of Koch snowflake
    drawKoch(0.0, 0.04, 3);
    drawKoch(-120.0, 0.04, 3);
    drawKoch(120.0, 0.04, 3);

    glEnd();
    glFlush();
}

// Main function
int main(int argc, char** argv) {
    glutInit(&argc, argv); 
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(500, 500);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Koch Curve");
    
    // Set background and projection
    glClearColor(1.0, 1.0, 1.0, 0.0);  // White background
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(-1.0, 1.0, -1.0, 1.0); // Coordinate system
    
    glutDisplayFunc(display);
    glutMainLoop();
    return 0;
}
